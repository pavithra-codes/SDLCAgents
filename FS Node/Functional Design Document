import os
import json
from typing_extensions import TypedDict
from dotenv import load_dotenv
from langgraph.graph import StateGraph, START, END
from langchain_core.messages import HumanMessage, SystemMessage
from langchain.prompts import ChatPromptTemplate
from langchain.schema.output_parser import StrOutputParser
from gen_ai_hub.proxy.langchain.init_models import init_llm
from reportlab.platypus import SimpleDocTemplate, Paragraph
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet
from datetime import datetime
import google.generativeai as genai

# Load environment variables
load_dotenv()
genai.configure(api_key=os.getenv("GEMINI_API_KEY")) # Add your api key

# Define State
class FDDState(TypedDict):
    brd: str
    fdd_gpt4o: str
    fdd_gemini: str
    fdd_final: str
    pdf_path: str

# Import BRD data
from brd_data import brd_data

# Initialize GPT-4o
llm_gpt4o = init_llm("gpt-4o").bind(max_completion_tokens=None)

# Gemini Generation Node
API_KEY = os.getenv("GOOGLE_API_KEY")
genai.configure(api_key=API_KEY)

def generate_fdd_gemini(state: FDDState) -> FDDState:
    model = genai.GenerativeModel(model_name="gemini-2.0-flash")
    prompt = f"""
You are a Senior SAP Functional Consultant. Create a Functional Design Document (FDD) using the following sections:

1. Introduction (Purpose, Scope)
2. Business Requirements
3. Functional Requirements
4. Assumptions and Constraints
5. In-Scope / Out-of-Scope
6. Process Flow Description (describe in text)
7. Use Case Scenarios
8. Screen Layout / Field Mapping (describe if applicable)
9. Security and Roles
10. Error Handling
11. Dependencies
12. Appendix (optional)

Ensure each section is clearly titled and structured. Base your content on the BRD input provided.

BRD Content:
{state['brd']}
"""
    response = model.generate_content(prompt)
    fdd_text = response.text
    return {**state, "fdd_gemini": fdd_text}

# GPT-4o Generation Node
def generate_fdd_gpt4o(state: FDDState) -> FDDState:
    prompt = ChatPromptTemplate.from_messages([
        SystemMessage(content="""You are a Senior SAP Functional Consultant. Create a Functional Design Document (FDD) using the following sections:

1. Introduction (Purpose, Scope)
2. Business Requirements
3. Functional Requirements
4. Assumptions and Constraints
5. In-Scope / Out-of-Scope
6. Process Flow Description (describe in text)
7. Use Case Scenarios
8. Screen Layout / Field Mapping (describe if applicable)
9. Security and Roles
10. Error Handling
11. Dependencies
12. Appendix (optional)

Ensure each section is clearly titled and structured. Base your content on the BRD input provided.
"""),
        HumanMessage(content=f"BRD Content: {state['brd']}")
    ])
    chain = prompt | llm_gpt4o | StrOutputParser()
    fdd_text = chain.invoke({"input": state["brd"]})
    return {**state, "fdd_gpt4o": fdd_text}

# Validation and Merge Node
def validate_and_merge_fdd(state: FDDState) -> FDDState:
    prompt = ChatPromptTemplate.from_messages([
        SystemMessage(content="""You are a senior SAP consultant. You are given two versions of a Functional Design Document (FDD) generated by different LLMs. Your task is to compare both and merge the best parts into a single, high-quality FDD. Ensure clarity, completeness, and structure."""),
        HumanMessage(content=f"FDD from GPT-4o:\n{state['fdd_gpt4o']}\n\nFDD from Gemini:\n{state['fdd_gemini']}")
    ])
    chain = prompt | llm_gpt4o | StrOutputParser()
    merged_fdd = chain.invoke({"input": ""})
    return {**state, "fdd_final": merged_fdd}

# PDF Output Node
def output_fdd_pdf(state: FDDState) -> FDDState:
    styles = getSampleStyleSheet()
    pdf_path = f"FDD_Output_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
    doc = SimpleDocTemplate(pdf_path, pagesize=letter)
    elements = [Paragraph("Functional Design Document (FDD)", styles['Title'])]

    for line in state["fdd_final"].split("\n"):
        if line.strip():
            elements.append(Paragraph(line.strip(), styles["Normal"]))

    doc.build(elements)
    return {**state, "pdf_path": pdf_path}

# Graph Setup
graph = StateGraph(FDDState)
graph.add_node("generate_gpt4o", generate_fdd_gpt4o)
graph.add_node("generate_gemini", generate_fdd_gemini)
graph.add_node("validate_merge", validate_and_merge_fdd)
graph.add_node("output_pdf", output_fdd_pdf)

graph.add_edge(START, "generate_gpt4o")
graph.add_edge("generate_gpt4o", "generate_gemini")
graph.add_edge("generate_gemini", "validate_merge")
graph.add_edge("validate_merge", "output_pdf")
graph.add_edge("output_pdf", END)

app = graph.compile()

# Run
initial_state = {
    "brd": json.dumps(brd_data),
    "fdd_gpt4o": "",
    "fdd_gemini": "",
    "fdd_final": "",
    "pdf_path": ""
}

result = app.invoke(initial_state)
print("FDD PDF generated at:", result["pdf_path"])
